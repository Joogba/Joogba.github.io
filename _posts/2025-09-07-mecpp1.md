---
title: "More Effective C++ 정리 1"
date: 2024-09-07
layout: single
classes: wide
---


## 4. 객체를 사용하기전에 초기화 하자
1. 기본 타입은 직접 초기화하자.
2. 생성자 멤버 이니셜라이져를 즐겨 쓰자. / 순서는 멤버 변수가 선언된 순서대로 하자.
3. 전역 static 객체는 초기화 문제가 발생할수있다. 이것을 지역 static 객체로 바꿔쓸 수 있다.

``` c++
1. class FileSystem { ... };

2. FileSystem& tfs(void) // 이 함수는 FileSystem 클래스 안에
3. { // 정적 멤버로 들어가도 됩니다.

4. static FileSystem fs; // 지역 정적 객체를 정의하고 초기화 합니다.
5. return fs; // 이 객체에 대한 참조자를 반환합니다.
6. } // 지역 정적 객체는 함수가 처음 불릴 때
7. // 반드시 초기화 됩니다.
8. class Directory { ... };

9. Directory::Directory( params )
10. {
11. ... // tfs의 참조자였던 것이 tfs()로 바뀌었습니다.
12. std::size_t disks = tfs().numDisks();
13. ...
14. }
```

싱글톤 스타일 함수 인데 전역으로 리소스를 관리하는 Manager류 클래스를 만들때 사용해야겠다.
# Chapter 2

## 5. C++ 가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자

기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자 같은 경우를 말한다. 인지하고 있자

## 6. 필요없으면 사용을 금해버리자

컴파일러가 자동으로 제공하는 기능을 허용하지 않으려면
1. private로 선언, 구현은 X
2. 예시와 같은 기본클래스 사용
``` c++
1. class Uncopyable {
2. protected: // 파생된 객체에 대해서
3. Uncopyable(void) {} // 생성과 소멸을
4. ~Uncopyable(void) {} // 허용합니다.

5. private:
6. Uncopyable(const Uncopyable&); // 하지만 복사는 방지합니다.
7. Uncopyable& operator=(const Uncopyable&);
8. };

9. class HomeForSale: private Uncopyable { // 복사 생성자도,
10. ... // 복사 대입 연산자도
11. };
```

모던 C++ 에서는 " =delete , =default " 와같은걸 쓰자
```c++
class HomeForSale {
public:
    HomeForSale() = default;
    ~HomeForSale() = default;

    HomeForSale(const HomeForSale&) = delete;
    HomeForSale& operator=(const HomeForSale&) = delete;
};

```
더 명확하고 가독성이 좋다.

d3device, rendercontext, window, swapchain과같이 os나 gpu리소스를 소유하거나 핸들을 관리하므로 복사되면 리소스 중복해제, 충돌이 일어날수 있다. 아마 내부적으로 dx가 해놨을수도 있지만 래퍼를 만든다면 써보자


## 7. 다형성을 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자

넥슨 기술면접에도 나온 내용이다. 클래스에 가상함수가 하나라도 있으면 
소멸자가 가상이 아닌경우 파생클래스 객체를 부모클래스 포인터에 담아 delete할때 부모의 소멸자만 호출되어 메모리 누락이 일어날수있다.
다형성을 갖지 않으면 가상 소멸자를 쓰면 안된다.

## 8. 예외가 소멸자를 떠나지 못하도록 붙들어 놓자

C++ 에는 스택 되감기라는 것이 존재한다.
예외를 던지고 try-catch 하지 않으면 지역변수(객체)의 소멸자를 호출하면서 main까지 도달한다. (RAII 철학)

이 과정에서 되감기도중 또다른 예외가 throw된다면 종료되거나 정의되지 않은 동작이 될수있다.

``` c++
class A {
    ~A() { throw std::runtime_error("소멸자 예외!"); }
};

void f() {
    A a;
    throw std::runtime_error("일반 예외!");
} // 문제 발생!!

```
소멸자 안에 예외발생 가능한 코드를 아예 넣지 않는게 베스트이다. 하지만 예외를 던질 가능성이 있다면 try-catch를 반드시 하자.

그럼 중요한 작업이 예외를 던질수 있다면 소멸자에서 작업하지말고 일반 함수로 분리해서 사용자가 호출하게 하면된다. (소멸자에서 예외를 던지는것을 차단해버리기 왜냐면 소멸자에서 예외를 처리하려면 종료하거나 삼키기를 하는수밖에없다. 안정성을 위해)

``` c++
class DBConn {
public:
	void close() {
		db.close(); // 이건 예외를 던질 수 있음
		closed = true;
	}

	~DBConn() {
		if (!closed) {
			try {
				db.close(); // 예외 던지지 않도록 try-catch
			} catch (...) {
				// 로그 남기거나 abort() 호출
			}
		}
	}
};
```
이렇게 close를 만들어두면 사용자는 
``` c++
try {
	dbconn.close(); // 실패하면 직접 예외 처리 가능
} catch (const std::exception& e) {
	std::cerr << "DB 닫기 실패: " << e.what() << '\n';
}
```
사용자가 처리하게 할수있다.
내 엔진에서 자원관리 클래스들을 짤때 이런함수들을 만들어 놔야겠다.

## 9. 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자.

생성자나 소멸자에서 가상함수를 호출해도 
실행중인 생성자 및 소멸자의 파생클래스 쪽으론 내려가지 않는다.
이미 소멸되었거나 아직 생성되지 않았기 때문이다.

필요하다면 별도 init()함수로 분리하거나 소멸자 에서의 호출 대신에 close나 Destroy()같은 함수에서 처리하자

## 10. 대입 연산자는 * this 의 참조자를 반환하게 하자

단순 = 연산자 말고도 += 같은 대입연산이 실행되는 곳에서 지켜야한다. int를 보면 연쇄 대입이 가능하다
int a,b,c;
a = b= c = 10;
이것이 * this 를 반환하기 때문

엔진에서 Transform Vector같은걸 직접 구현해서 제공하려면 꼭 반환하자.

## 11. operator= 에서는 자기대입에 대한 처리가 빠지지 않도록 하자.

그럼 어떤처리를 해야할까
1. 원본객체와 복사대상 객체의 주소 비교
2. 문장 순서 조정
3. 복사 후 맞바꾸기 기법

자기 대입 처리를 하지 않는다면?
```c++
Widget& Widget::operator=(const Widget& rhs)
{
    delete data;            // 먼저 기존 데이터 삭제
    data = new int(*rhs.data);  // rhs가 자기 자신이라면? 이미 삭제됨!
    return *this;
}
```
이런 문제가 생기게 된다.

그래서 
주소를 비교하거나
```c++
if (this == &rhs) return *this;
```

복사 후 맞바꾸기를 한다.
```c++
1. class Widget {
2. ...
3. void swap(Widget &rhs); // *this의 데이터 및 rhs이 데이터를 맞바꿉니다.
4. ...
5. };

6. Widget& Widget::operator=(const Widget& rhs)
7. {
8. Widget temp(rhs); // rhs의 데이터에 대해 사본을 하나 만듭니다.
9. swap(temp); // *this의 데이터를 그 사본의 것과 맞바꿉니다.
10. return *this;
11. }

12. Widget& Widget::operator=(Widget rhs) // rhs는 넘어온 원래 객체의 사본입니다.
13. { // (값에 의한 전달)

14. swap(rhs); // *this의 데이터를 이 사본의
15. // 데이터와 맞바꿉니다.
16. return *this;
17. }
```
 장점은
코드가 간결해지고
복사 생성자가 실패해도 * this 는 아무 영향도 받지 않는다.
swap 함수하나만 잘 정의하면 복사, 이동 대입 연산자 / 이동 생성자 swap로직에서도 모두 사용가능하다.

엔진을 만들때 리소스 끼리 복잡한 객체가 많은데 예외 안정성을 보장해주어서 Texture를 GPU에 대입할때와 같은 로직을 가진 함수를 클래스를 만들때 편할 것 같다.
Directx 같은경우 로우 포인터를 사용한다 Comptr도 있지만 사용하지 않을때는 이런 래핑 클래스를 만들어주면 좋을것같다. 왠만하면 comptr을 쓰자

#### 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해 보세요.

인자로 두개의 객체를 받는데 실제로는 하나를 가리킬때 주의해야한다. 함수가 데이터를 교환하거나 복사, 삭제할때 객체가 같으면 데이터가 망가질수있다.

## 12. 객체의 모든 부분을 빠짐없이 복사하자.

 #### 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 말고 복사해야 합니다.

    
 #### 클래스의 복사 함수 두 개(복사 생성자, 복사 대입 연산자)를 구현할 때, 한쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 마세요. 그 대신, 공통된 동작을 제3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결합시다.

서로 용도와 동작이 다르다 코드가 복잡해지고 의도하지 않은 무한 재귀 가능성도 있다고 한다.

``` c++
class MyClass : public BaseClass {
public:
    int x;
    std::string str;

    // 공통 복사 함수
    void copyFrom(const MyClass& other) {
        BaseClass::operator=(other); // 기본 클래스 부분 복사
        x = other.x;
        str = other.str;
    }

    // 복사 생성자
    MyClass(const MyClass& other) : BaseClass(other) { // 기본 클래스 복사 생성자 호출
        copyFrom(other);
    }

    // 복사 대입 연산자
    MyClass& operator=(const MyClass& other) {
        if (this != &other) {
            copyFrom(other);
        }
        return *this;
    }
};

```
